# Инициализация состояния

Существует два основных способа для задания начального состояния  приложения. 
Метод `createStore` может принимать необязательное значение `preloadedState` в качестве второго аргумента.
Редьюссеры также могут задавать начальное состояние, ища входящий аргумент `state`, 
который равен `undefined`, и возвращая значение, которое они хотели бы использовать по умолчанию. 
Это можно сделать либо с явной проверкой внутри редьюссера:
 ```js
function  myReducer(state , action){
    state = (state !== undefined) sate : someDefaultValue;
    }
}
```
либо с помощью синтаксиса значения аргумента по умолчанию ES6: 
```js
function myReducer(state = someDefaultValue, action)
```  

Не всегда сразу понятно, как эти два подхода взаимодействуют.  
К счастью, этот процесс следует некоторым предсказуемым правилам. 
Вот как происходит определение начального состояния.

## Итоги

Без `combineReducers()` или анологичного дополнительного кода,
`preloadedState` имеет более высокий приоретет, чем `state = ...` в редьюссерае,
потому что `state`, переданное в редьюссер *это* `preloadedState` и *оно не равно* `undefined`,
поэтому значение аргумента по умолчанию, определенное в синтаксисе ES6, не будет применено.

С `combineReducers()` поведение более сложное. 
Те редьюссеры, чьё состояние описано в  `preloadedState` получат это состояние. 
Дргуие будут `undefined` и получат значение по умолчанию, указанное в  `state = ...`.

**В итоге, `preloadedState` имеет более высокий приоретет, чем значение `state` по умолчанию, описанное в редьюссере.
Это дает возможность указывать в редьюссере значения `state` по умолчанию, 
а также загружать существующие данные  (полностью или частично) 
при гидратации хранилища из некоторого постоянного хранилища или сервера.**

## Подробности


### Single Simple Reducer
Сначала рассмотрим случай когда у вас один редьюссер, т.е. вы не используете `combineReducers()`.

Ваш редьюссер может выгдеть как-нибудь так:

```js
function counter(state = 0, action) {
  switch (action.type) {
  case 'INCREMENT': return state + 1;
  case 'DECREMENT': return state - 1;
  default: return state;
  }
}
```

Теперь создадим хранилище.

```js
import { createStore } from 'redux';
let store = createStore(counter);
console.log(store.getState()); // 0
```

Начальное значение `0`. Почему?   
Потому что второй агрумент в  `createStore` не был передан, 
а значит `undefined`. Это `state` переданное нашему редьюссеру в первый раз. 
Когда Redux иницализирует наше хранилице, он отправляет "фиктивное" действие (action)
для заполнения состояний. 
Таким образом, наш редьюссер `counter` был вызван с `state` равным `undefined`. 
**Это именно тот случай, когда" активируется " аргумент по умолчанию.** 
Таким образом, `state` теперь `0`, как указано в значении по умолчанию для `state`  (`state = 0`). 
Это значение (`0`) и вернет `getState()`.

Давайте рассмотрим другой сценарий:

```js
import { createStore } from 'redux';
let store = createStore(counter, 42);
console.log(store.getState()); // 42
```

Почему в этот раз значение `42`, а не `0`? 
Потому что `createStore` вызвано со вторым аргументом `42`. 
Этот аргумент становится `state` переданным нашему редьюссеру вместе с "фиктивным" действием. 
**В этот раз, `state` не равно undefined (оно равно `42`!), 
и значение аргумента по умолчанию синтаксиса ES6 не применяется.** 
`state` равно `42`, и `42` возвращается из редьюссера.


### Составные редьюссеры

Теперь рассмотрим случай использования `combineReducers()`.  
У нас есть два редьюссера:
 
 ```js
function a(state = 'lol', action) {
  return state;
}

function b(state = 'wat', action) {
  return state;
}
```

Редьюссер, генерируемый `combineReducers({ a, b })` выглядит так:

```js
// const combined = combineReducers({ a, b })
function combined(state = {}, action) {
  return {
	a: a(state.a, action),
	b: b(state.b, action)
  };
}
```

Если мы вызовем `createStore` без `preloadedState`, 
то `state` будем инициализированно значением `{}`. 
Следовательно, `state.a` and `state.b` будут `undefined` в момент вызова редьюссеров `a` and `b`. 
**Редьюссеры `a` и `b` получат `undefined` в качестве аргументов `state`,
если для `state` задано значение по умолчанию, то оно будет использовано.** 
Вот как комбинированный редьюссер возвращает объект состояния `{ a: 'lol', b: 'wat' }` при первом вызове.

```js
import { createStore } from 'redux';
let store = createStore(combined);
console.log(store.getState()); // { a: 'lol', b: 'wat' }
```

Теперь рассмотрим другой сценарий:

```js
import { createStore } from 'redux';
let store = createStore(combined, { a: 'horse' });
console.log(store.getState()); // { a: 'horse', b: 'wat' }
```

Теперь мы указали `preloadedState` как аргумент для  `createStore()`. 
Состояние, вернувшееся из комбинированного редьюссера *объеденяет* начальное состояние, которое мы описали
 для редьюссера `a: 'horse'` и `'wat'`, заданное как начальное состояние в редьюссере `b`.

Вспомним, что делает комбинированный редьюссер:

```js
// const combined = combineReducers({ a, b })
function combined(state = {}, action) {
  return {
	a: a(state.a, action),
	b: b(state.b, action)
  };
}
```

В нашем случаее, т.к. `state` было передано в `combined`, оно не получает значения `{}`.
Был передан объект, содержащий поле`a`, равное `'horse'`, но не содержащий поле `b`. 
  Вот почему редьюссер `a` получил `'horse'` как свое `state` , а редьюссер `b` получил `undefined` 
  как аргумент `state` и вернул знчение по умолчанию, заданное для `state` (в нашем примере, `'wat'`). 
  Вот так в итоге мы получили `{ a: 'horse', b: 'wat' }`.


## Резюме

Подводя итог, если вы придерживаетесь соглашений Redux и возвращаете начальное состояние из редьюссера, 
когда они вызываются с `undefined` в качестве аргумента `state` 
(самый простой способ реализовать это - указать значение аргумента по умолчанию "state", используя синтаксис ES6), 
у вас будет хорошая возможность для комбинированных редьюссеров. 
**Более высокий приоретет будет иметь значение в объекте "preloadedState", которое вы передаете функции `createStore()`, но 
если вы не передали ни одного или если соответствующее поле не установлено, 
вместо этого выбирается аргумент "state" по умолчанию, указанный редьюссером.** 
Этот подход хорошо работает, поскольку он обеспечивает как инициализацию, 
так и гидратацию существующих данных, и позволяет отдельным редукторам сбрасывать свое состояние,
 если их данные не были сохранены. 
 Конечно, вы можете применить этот шаблон рекурсивно, 
 так как вы можете использовать combineReducers () на многих уровнях или даже создавать редьюссеры вручную, 
 вызывая их и предоставляя им соответствующую часть дерева состояний.